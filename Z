# Inverse normal CDF (ppf) without SciPy â€” Acklam's approximation
from math import sqrt, log

def norm_ppf(p: float) -> float:
    # Validate p
    if not (0.0 < p < 1.0):
        raise ValueError("p must be in (0,1)")

    # Coefficients (Peter John Acklam)
    a = [-3.969683028665376e+01,  2.209460984245205e+02,
         -2.759285104469687e+02,  1.383577518672690e+02,
         -3.066479806614716e+01,  2.506628277459239e+00]
    b = [-5.447609879822406e+01,  1.615858368580409e+02,
         -1.556989798598866e+02,  6.680131188771972e+01,
         -1.328068155288572e+01]
    c = [-7.784894002430293e-03, -3.223964580411365e-01,
         -2.400758277161838e+00, -2.549732539343734e+00,
          4.374664141464968e+00,  2.938163982698783e+00]
    d = [ 7.784695709041462e-03,  3.224671290700398e-01,
          2.445134137142996e+00,  3.754408661907416e+00]

    # Break-points
    plow  = 0.02425
    phigh = 1 - plow

    if p < plow:
        # Rational approximation for lower region
        q = sqrt(-2*log(p))
        return (((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5]) / \
               ((((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1)
    elif phigh < p:
        # Rational approximation for upper region
        q = sqrt(-2*log(1 - p))
        return -(((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5]) / \
                 ((((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1)
    else:
        # Rational approximation for central region
        q = p - 0.5
        r = q*q
        num = (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5]) * q
        den = (((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1)
        return num / den

def z_from_nc(nc: float) -> float:
    # two-sided confidence -> central area = nc
    p = 1 - (1 - nc)/2.0
    return norm_ppf(p)

# Ejemplos:
# z_from_nc(0.66)  ~ 0.954
# z_from_nc(0.95)  ~ 1.95996




# Inverse normal CDF (ppf) by binary search using erf (no external libs)
from math import erf, sqrt

def norm_cdf(x: float) -> float:
    # Standard normal CDF via error function
    return 0.5 * (1.0 + erf(x / sqrt(2.0)))

def norm_ppf_binary(p: float, tol: float = 1e-10) -> float:
    if not (0.0 < p < 1.0):
        raise ValueError("p must be in (0,1)")
    # Reasonable initial brackets for Z
    lo, hi = -10.0, 10.0
    while hi - lo > tol:
        mid = 0.5 * (lo + hi)
        if norm_cdf(mid) < p:
            lo = mid
        else:
            hi = mid
    return 0.5 * (lo + hi)

def z_from_nc_binary(nc: float) -> float:
    p = 1 - (1 - nc)/2.0
    return norm_ppf_binary(p)

# Ejemplos:
# z_from_nc_binary(0.66) ~ 0.954
# z_from_nc_binary(0.95) ~ 1.95996
